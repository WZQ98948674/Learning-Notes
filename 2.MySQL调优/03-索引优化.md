### 索引优化
####  1. 树结构变化过程

- 二叉树 : 
  - 缺点: 会产生一个腿长一个腿短的情况 , 降低查询效率
- 搜索二叉树 (BST):
  - 缺点 : 跟二叉树一样 , 只不过加了搜索功能
- 平衡二叉树 (AVL):
  - 特点 : 最长腿和最短腿差距不超过1 (旋转)
  - 缺点 : 当数据单边插入时 , 会产生1-n次的旋转 , 所以在增删时 , 效率低 , 查询时效率高
- 红黑树 (RBT) :
  - 特点 :
    1.  最长腿不超过最短腿的二倍 (旋转 + 变色)
    2. 任意一条路线上不允许出现两个连续的红色节点
    3. 从根节点到子节点的任意路线上 , 黑色节点的个数都一致
  - 缺点 :  损失了部分的查询效率 , 弥补了增删效率
- B树:    (图片)
  - 特点 : 
    1. 不限制子节点的个数为3 , 可以为n个
    2. 所有子节点都存储了数据
  - 缺点 : 
    1. 所有非叶子节点都存储了数据 , 占用了空间 , 导致MySQL每次IO读取时实际读取的数据量变小,需要更多次IO (例如: InnoDB引擎每次读取16kb , 即4页 , 由于所有子节点都存储了data , 所以每个子节点可以存储的指针数据就变少了 , 每个子节点的子节点就变少了 , 每次IO读取到的数据就变少了)
- B+树 :   (图片)
  - 特点 : 
    1. B树的优化 , 去除了所有非叶子节点中的data , 改为存储更多的指针 , data数据全部存储在叶子节点中
    2. 所有的叶子节点中都存在指针,连接至下一个叶子节点,保证数据的连续查找

#### 2. 索引的数据结构

- hash索引:  

  - 使用点 : MySQL中memory引擎就是使用hash索引,因为memory存储于内存中

  - 缺点

    1. hash索引需要把所有数据放在内存中进行处理(根据下标获取值),对内存有较大压力
2. 链表时等值匹配,而公司中的业务场景多为范围搜索, 所以不太适用
- B+树索引 : 
  - 使用点 :  myisam和InnoDB引擎使用的都是B+树索引 , 
  - 区别 : 
    1. InnoDB的数据和索引放在一起,myisam的数据和索引是分开放的
    2. InnoDB的叶子节点中存储的是完整的数据 , MySIAM中叶子节点存储的是数据的地址,还要找到数据文件 , 根据地址找到完整数据 ,多了一次IO .

#### 3. 索引的基础知识

1. **索引的优点**:

   1. 大大减少需要扫描的数据量
   2. 帮助服务器避免排序和临时表(索引已经自动排序了)
   3. 将随机IO变成顺序IO

2. **索引的用处**: 

   1. 快速匹配where字句
   2. 

3. **索引的分类**: 数据库会自动给唯一键建索引.

   - 主键索引 : 只有主键索引是和数据放在一起的
   - 唯一索引
   - 普通索引
   - 组合索引
   - 全文索引

4. **技术名词**: 

   - **回表** : ***<u>普通列创建的索引</u>*** , 叶子节点中存储的并不是完整数据 , 而是主键的值 , 然后通过主键    的值 , 查找主键的索引树 , 找到完整数据 , 这个过程就叫回表 .  
   - **覆盖索引** : 本来sql为select * from user where name = 'aaa' , 需要通过name索引树找到id,然后通过id索引树找到完整数据 , 如果把sql改为  select  id from user where name = 'aaa'或者select  id,name from user where name = 'aaa' , 那么在通过name索引树找到id后 , 无需再去id索引树中查找数据 , 则被称为覆盖索引 , 减少了一次IO , 索引覆盖索引应该能使用则使用 .  (Extra = Using index)
   - **最左匹配** : ***<u>组合索引中</u>*** , where后的条件必须按照索引顺序从左到右匹配 , 否则无法使用索引 . 例如 : 建立name+age的组合索引 , sql为 select * from user where  name = ? and age = ? 此时可以使用索引 , 如果sql 为 select * from user where age = ? , 此时无法使用索引 , 因为此组合索引最先匹配的为name, 可以将组合索引的顺序改为age+name或者给age单独创建一个索引.
   - **索引下推** : 建立name+age的***<u>组合索引</u>*** , sql为 select * from user where  name = ? and age = ? , 低版本中是在存储引擎中按照name过滤 , 然后再server层中按照age过滤 , 在高版本中再存储引擎中直接按照name和age全部过滤 , 减少了server层中的数据 , 这就叫索引下推 .
   - **索引合并** :

5. **索引匹配方式**:

   表中创建name+age+pos的组合索引   alter table user add index index1(name,age,pos);

   - **全值匹配** : 
     - 使用的全部的组合索引精确匹配 , 这就是全值匹配
     - select * from user where name='a' and age = 10 and pos ='ff'; 
   - **匹配最左前缀** : 
     - 只匹配前边的几列, 并且是精确匹配
     - select * from user where name='a' and age = 10 ; 使用组合索引中前边的部分精确匹配 , 就是匹配最左前缀.
   - **匹配列前缀** :  
     - 可以匹配某一列的开头部分
     - select * from user where name='a%' ; 
   - **匹配范围值** :  
     - 可以查找一个范围的数据
     - select * from user where name > 'a' ; 
   - **精准匹配某一列并范围匹配另外一列** :
     - 可以精准匹配某一列 , 并且范围匹配另一列
     - select * from user where name =  'a' and age > 25 ; 
   - **只访问索引的查询** :
     - 查询上只访问索引, 不需要访问数据行 , 实际上就是覆盖索引
     - select name,age,pos from user where name='a' and age = 10 and pos ='ff';
   
   **注1: 组合索引只需要考虑在查询时尽量带上所有组合索引的索引字段 , 索引使用的越多, 查询效率越高 .**
   
   **注2: select * from user where name='a' and age>10 and pos ='ff'; 这种情况下只是用了name和age索引, 因为age索引是范围匹配, 索引后边的索引都不会生效了.** 
   
   **注3 : mysql会对sql语句进行优化 , 即在查询时颠倒name,age,pos的顺序 , 但是sql执行时仍然会走组合索引 , 就是因为MySQL对其进行了优化 .** 
   
   **注4 : 创建组合索引的时候尽量选择字段长度小的列进行创建 , 会减少索引的存储空间 , 从而减少IO次数 .**

#### 4. 哈希索引

   1. **特点**:
      1. 只有精确匹配索引所有列的查询才有效
      2. mysql中只有memory引擎使用哈希索引
      3. 哈希索引自身只存储对应的hash值, 所以索引的结构十分紧凑, 查找速度非常快
   2. 使用限制
      - 哈希索引只存储哈希值和行指针, 不存储字段值 , 所以不能使用索引中的值来避免行读取
      - 哈希索引数据并不是按照索引值的顺序进行存储的, 所以无法排序
      - 哈希索引不支持部分匹配查找 , 因为哈希值是按照全部索引进行计算的
      - 哈希索引支持等值查找, 不支持范围查找
      - 访问哈希索引的数据非常快 , 除非有很多哈希冲突
      - 哈希冲突特别多的话 , 维护代价也很大

#### 5. 聚簇索引和非聚簇索引

 	1. 聚簇索引 : 不是单独的索引类型, 而是一种数据的存储方式, 指的是数据行跟相邻的键值紧凑的存储在一起.	(*.idb -数据+索引文件)
     - 优点:
       - 数据访问更快,因为存储在同一文件中
       - 可以使用覆盖索引
     - 缺点 : 
       - 插入速度严重依赖于插入顺序, 按照主键的顺序插入是最快的方式
       - 频繁的插入和删除会导致频繁的页分裂和页合并, 产生大量IO, 影响数据库效率

​	2. 非聚簇索引: 数据文件和索引文件分开存放.  (*.nyd -数据文件    *.nyi - 索引文件)



1. InnoDB是聚簇索引, 因为索引和数据放在同一个文件.
2.  MyISAM是非聚簇索引. 

#### 6. 覆盖索引

​	md文档.

#### 7. 优化细节

1. **当使用索引列进行查询时, 尽量不要使用表达式, 把计算放到业务层而不是数据层, 会导致执行计划的优先级降低** ( **system>const>ref>range>index>all** )

   - 反例 : select id from user where id+1=5;         index
   - 正例 : select id from user where id=4;             const

2. **尽量使用主键查询, 而不是其他索引, 因为主键查询不会触发回表**

3. **使用前缀索引**   (**md文档**)

   - 提交查询速度,降低索引选择性(命中率)
   - 取字段的前几位作为索引,而不是使用整体作为索引, 一般来说, 位数越多, 索引的选择性越高, 查询效率越高

4. **使用索引扫描来排序**(**md文档**)

   - mysql有两种方式可以生成有序的结果集: 
     - 排序   (explain中using filesort)
     - 索引扫描  (explain中using index )
   - 索引本身是有序的, 既可以用来查找, 也可以用来排序, 但是如果索引不能覆盖所有的列, 则需要进行一次回表, 全表扫描

5. **union all , in , or 都可以使用索引 , 但是推荐使用 in**

   - 可以尝试下边几个sql的执行计划
     - explain select * from user where id =1 union all select * from user where id=2;
     - explain seelct * from user where id in (1,2);
     - explain select * from user where id = 1 or id =2;
   - union 和 union all的区别
     - union会增加一个distinct的过程, 速度会慢一点
     - union all 不会去重, 速度会快一点, 所以在不需要去重的情况下, 优先选择union all

6. **范围列可以使用索引, 但是后边的列无法使用索引, 索引最多作用于一个范围列**

   - 当范围列是组合索引的第一个字段时

7. **强制类型转换会全表扫描**

   - phone字段为varchar(11) , 有索引 
   - explain select * from user where phone = 13689744319;          不走索引
   - explain select * from user where phone = '13698744319';         走索引

8. **更新十分频繁, 数据区分度不高的字段不建议建索引**

   - 更新会改变索引的B+树, 频繁的更新会大大降低数据库的性能( 乱序, 页分裂和页合并 )

   - 类似于性别等区分度不高的字段, 建立索引没有意义, 因为并不能有效的过滤数据

   - 一般区分度在80%的可以建立索引, 区分度可以使用 

     select count(distinct(列名))/count(*)  from 表名 计算

9. **创建索引的列, 不允许为null**

   - 可能会得到不符合预期的结果

10. **当需要进行表连接时, 最好不要超过三张表, 因为需要join的字段, 数据类型最好一致**

    - join内部实现: 嵌套循环
    - 当非驱动表(匹配表)的join字段上没有索引时, 会取驱动表的每一条数据和匹配表的每一条数据进行匹配, 查询速度慢
    - 当非驱动表(匹配表)的join字段上有索引时, 会根据关联字段的索引进行查找, 当在索引上找到合适的值, 再回表进行查询, 也就是只有当匹配到索引以后才会进行回表查询, 速度大大提升 .
    - 当非驱动表的join字段为主键时, 速度会更快, 因为减少了回表的次数 , 当join字段不是主键而是其他索引字段时, 会先关联索引查询, 找到主键之后进行回表查询 .
    - **最优方式就是小表join大表, 大表的join字段有索引** . 把小表读取到内存(**join buffer** , 默认256k )中 , 跟磁盘中的大表进行逐条匹配

11. **如果明知道只有一条数据返回, 使用limit 1 提高效率**

    - 能使用limit的时候尽量使用limit

12. **单表索引尽量控制在5个以内**

    - 索引越多, 索引文件越大, io越多

13. **组合索引字段尽量控制在5个以内**

    - 最左匹配原则

#### 8.索引监控

```sql
--查看索引监控
show status like 'handler_read%';

--通过index获取数据的次数(越大越好,证明索引使用次数多)
handler_read_index 

--从数据节点读取下一条数据的次数(越大越好)
handler_read_rnd_next
```

#### 9. 索引优化案例

**md文档**



##### CRC32

循环冗余校验: 把较长的字符串变成固定长度的整数值, 在数据存储和数据读取中有很大作用. 

HyperLogLog:

DV :

基数 : 不重复数据的数量, 基数越小, 重复数据越多, 查询速度越快

​    