#### 分区表

1. #### 定义 :

   按照自定义规则 , 把一张表分成多个部分存储 . (文件名带#号)

   ```sql
   create table user(
   	...
   	...
   )
   --按照id进行分区
   partition by range(id)(
   	--id小于100存入p0区
   	partition p0 values less then (100),
   	--id小于200存入p1区
   	partition p1 values less then (200),
   	--id小于300存入p2区
   	partition p2 values less then (300),
   	--id小于400存入p3区 (当id大于300时,插入报错)
   	--partition p3 values less then (400)
   	--id小于MAXVALUE存入p3区
   	partition p3 values less then MAXVALUE
   );
   ```

2. #### 应用场景 (目的就是减少整体的IO量)

   1. 表非常大, 无法完全放进内存 或者只在表的最后部分由热点数据 ,其余都是历史数据

   2. 分区表更容易维护 ,

      - 批量删除大量数据时可以使用清除整个分区的方式

      - 对一个独立分区进行优化, 检查, 修复等操作

   3. 分区表的数据可以分布在不同的物理设备上, 从而高效的使用多个硬件设备

   4. 可以使用分区表来避免某些特别的瓶颈

      - innodB单个索引的互斥访问 (锁)
      - ext3文件系统的inode锁竞争 

   5. 可以备份和恢复独立的分区

3. #### 分区表的限制

   1. 一个表最多有1024个分区, 5.7版本之后最多有8096个分区  ( 与linux的fd相关 )
   2. 低版本mysql中, 分区表达式必须是整数或者返回整数的表达式, 5.5以上 某些场景可以直接使用列来进行分区
   3. 如果分区字段中有主键或者唯一索引的列, 那么**所有主键列和唯一索引列都必须包含进来**
   4. 分区表无法使用外键约束
   
4. #### 分区表的底层原理

   1. select语句 :
      - 当查询一个分区表时, 分区层先打开并锁住所有的底层表, 优化器先判断是否可以过滤部分分区, 然后再调用对应的存储引擎接口访问各个分区的数据
   2. insert语句
      - 当插入一条数据时, 分区层先打开并锁住所有底层表, 然后判断是哪个分区接受这条数据, 然后再将记录写入对应底层表
   3. delete语句
      - 当删除一条数据时, 分区层先打开并锁住所有的底层表, 然后确定数据所在的分区, 再对应的底层表执行删除操作
   4. update语句
      - 当更新一条数据时, 分区层先打开并锁住所有底层表, 然后确定目标数据所在的分区, 然后在对应分区取出数据进行更新, 然后在确定更新后的数据应该存储在哪个分区, 然后在对应底层表插入数据, 最后在源数据的底层表进行删除操作
   5. 虽然所有的操作都会先'打开并锁住所有表', 但并不是说分区表在处理过程中是锁住全表的, 如果存储引擎能自己实现行锁(如innoDB), 则会在分区层释放对应表锁

5. #### 分区方式

   1. 范围分区 (id,**时间**...)
   2. 列表分区 (和范围分区差不多)
   3. 列分区 (范围分区和列表分区的整合, 没有数据类型的限制)
   4. hash分区 (根据字段值和分区数量, 进行hash(取模)确定分区)
   5. key分区 (按主键或唯一键和分区数量进行分区 , hash分区的变种)
   6. 子分区 (在分区上再进行分区)