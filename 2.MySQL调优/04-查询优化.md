#### 查询优化

#### 1. 查询慢的原因

1. 网络IO
2. cpu
3. IO
4. 上下文切换 : 任务切换
5. 系统调用
6. 生成统计信息
7. 锁等待时间 : 并发场景
   - MySAIM : 共享独锁 , 独占写锁            只能锁表
   - InnoDB : 共享锁 , 排他锁                   可以锁表, 也可以锁行 ( 实际锁的是索引 , 如果锁的字段带有索引 , 那就是行锁 , 如果字段没有索引 , 就会退化为行锁 ) 

#### 2. 优化数据访问

1. **减少访问数据量  (IO)**

   - 确认应用程序是否在检索大量超过需要的数据 (执行计划查看rows )
   - 确认mysql服务器是否正在分析大量超过需要的数据行 ( 并发情况下 )

2. **是否向数据库请求了不需要的数据**

   1. 查询不需要的数据 
      - 通常是使用select查询全量的数据, 在取需要的n行 , 应该为使用limit
   2. 多表关联时返回全部列
      - 不要写*  
   3. 总是取出全部列
      - 禁止使用select * 
   4. 重复查询相同的数据
      - 查询缓存 : mysql8之后不支持了 

#### 3. 执行过程的优化

   1. **查询缓存** : 是否打开(不常修改数据的表可以放入缓存中 , 减少缓存的修改率, 提高缓存的命中率)

   2. **查询优化处理**

      mysql查询完缓存之后, 会经历一下几个步骤 , 解析SQL -> 预处理 -> 优化SQL执行计划 , 这几个步骤出现任何错误 , 都可能终止查询

      - 语法解析器 :
        - mysql通过关键字对SQL进行解析 , 并生成一颗解析树 (抽象语法树 AST) , mysql解析器将使用mysql语法规则验证和解析查询, 例如验证是否使用了错误的关键字或者顺序是否正确等 ...
        - 预处理器会进一步检查解析树是否合法, 例如表名和列名是否存在 , 是否有歧义, 还会验证权限等... 
      - 查询优化器
        - 当语法没有任何问题之后, 要由优化器将其转化为执行计划, 一条SQL可以有很多种执行计划, 最后都可以得到相同的结果集, 但是不同的执行计划效率是不一样的 , 优化器的主要作用就是找到最有效的执行计划.
        - mysql使用的是基于成本的优化(CBO), 在优化时会尝试预测一个查询SQL使用某种执行计划的成本, 并选择成本最小的一个.
        1. 部分情况下mysql会选择错误的执行计划
           - 统计信息不准确
           - 成本估算不等于实际执行的成本
           - mysql的优化可能与我们想象的情况不一样
           - 不会考虑其他并发的查询情况
           - 不会考虑不受其控制的操作成本 ( 存储过程,自定义函数等... )
        2. 优化策略
           1. 静态优化 : 直接对解析树进行分析, 并完成优化
           2. 动态优化 : 动态优化与查询的上下文有关, 也可能与取值, 索引对应的行数有关
           3. 静态优化只需要一次 , 动态优化每次查询前都要进行评估
        3. 优化类型:
           1. 从新定义关联表的顺序
           2. 将外连接转化为内连接, 内连接的效率比外连接高
      
          3. 使用等价变换规则, 简化一些表达式(a>4 or a<4    ->  a!=4)
           1. 优化count() , min() ,max() 
           2. 转化表达式为常数, 如果mysql预估一个表达式为常数, 就会把一个表达式一直当做常数处理
           3. 索引覆盖查询
           4. 子查询优化
           5. 等值传播 (两个表通过一个字段关联时, 写条件只需要写一个字段就行, 因为两个值相同)
      
   4. **关联查询**

         1. simple nested-loop join

         2. index nested-loop join

         3. block nested-loop join

         强制优化器在join时从左到右执行 : 在select后加上 straight_join 再加字段 , 但是效率可能不如被优化
         
   5. **排序优化**

         排序算法

         1. 两次传输排序:
            - 定义 : 第一次先将需要排序的字段全部查询出来, 进行排序 , 第二次在根据排序的结果再去表中按照需要读取数据行
            - 缺点 : 效率比较低 , 第二次因为已经排好序了, 再去表中读取所有记录 , 都是随机IO , 成本比较高
            - 优点 : 在排序的时候存储的数据少 , 让排序缓冲区可以存储尽可能多的数据行数
         2. 单次传输排序 :
         
            - 定义 : 先读取查询所需要的所有字段 , 然后根据给定的字段进行排序 , 最后直接返回结果集
         
            - 缺点 : 查询的列特别多的时候 , 会一次性的占用大量的存储空间
         
            - 优点 : 只需要一次顺序IO读取所有的数据 , 无需任何随机IO 
         3. 使用选择 : 
            - 当需要排序的列的总大小加上order by的列大小超过max_length_for_sort_data(1024k)定义的字节, mysql会选择两次排序, 反之使用单次排序 , 用户可以设置此参数的值来选择排序的方式. 

#### 4. 优化特定类型的查询

1. 优化count()查询 :
   - count(*) 和 count(id) 和 count(1) 和count(非null字段)  的查询效率在没有where条件时是一模一样的
   - 优化的话 : 增加汇总表 , 增加缓存...
2. 优化关联查询 :
   - 确保on或者using子句中的列上有索引 , 创建索引的时候就要考虑到关联的顺序
3. 优化子查询 :
   - 尽可能使用关联查询替换 , 因为子查询产生的临时表最后还要与基表进行关联 , 而关联查询产生的临时表可以直接获取最终结果集
4. 优化limit分页 :
   - 尽可能使用覆盖索引 , 而不是查询所有的列
5. 优化union :
   - 除非非要查询去重之后的数据 , 否则建议使用union all替代union , 因为mysql在使用union的时候会给临时表上加上distinct关键字,大大降低效率
6. 推荐使用用户自定义变量
   1. @: 用户自定义变量 (当前会话有效) (mybatis的xml不支持)
      - set  @abc = 100;
      - select @i := @i +1 ;
   2. @@: 系统变量


