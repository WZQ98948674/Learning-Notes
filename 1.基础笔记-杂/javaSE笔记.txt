1.生成[a-b]之间的随机数
(int)(Math.random()*(b-a+1)+a)

2.switch-case结构：
	switch后可以跟  byte,short,char,int,枚举（jdk5），String（jdk7）
	case 后只可以跟常量，不能写范围


3.基本数据类型：
	四类八种（1byte字节=8bit位）

  引用数据类型：
	类（包含String）、数组、接口

4.栈(stack):局部变量
  堆(heap):new出来的东西：对象、数组
  方法区：常量池、静态域、类加载的信息


5.16进制：0x开头


6.引用类型的变量，存的要么是null，要么是地址值


7.数据结构：
	①数据与数据之间的逻辑关系：集合，一对一，一对多，多对多
	②数据的存储结构：
		线 性 表：顺序表（比如：数组）、链表、栈、队列
		树形结构：二叉树
		图形结构：


8.二分法查找：
	前提：所要查找的数组是有序的
	定义首尾索引，判断中间值和目标值的大小，更改首尾索引的值，循环条件为首索引值<=尾索引值


9.排序算法：
	优劣：
		时间复杂度（高效率），空间复杂度（少存储），稳定性（相同关键字，排序后顺序不变）
	分类：
		内部排序，外部排序（借助外部存储设备）
	排序算法：
		十大排序算法（冒泡、快速、堆排序、归并排序）


10.算法的5大特征：
	输入、输出、有限性、明确性、可行性


11.定义一个字符串，不赋值，直接调用会报错：未被赋值
   在类中定义一个字符串类型的属性，new对象调用该属性，结果为null

   原因：成员变量（属性）有默认初始化值，局部变量没有默认初始化值。



12.接口和抽象类的区别：
	成员：	抽象类：变量、常量、构造方法、抽象方法
		接口：  静态常量、静态抽象方法（1.8之前）
	关系：	类和抽象类：单继承
		类和接口：多实现
		接口和接口：多继承
	设计理念：	抽象类是对事物和行为的抽象
			接口只是对行为的抽象


	jdk1.8之后接口中加入了，默认方法和静态方法   java.util.List
	jdk1.9之后接口中加入了，私有方法

	
	默认方法：用于接口的升级，接口中加入新方法时，不需要所有的实现类都强制重写此方法，只给有需要的实现类进行重写
	静态方法：只能通过接口本身调用，不能使用接口实现类及实现类对象调用，防止一个实现类实现多个接口，多个接口中存在重名静态方法的问题
	私有方法：可以将接口中默认方法和静态方法中的公共代码抽离成私有方法，供自己使用


13.线程的创建方式：
	1.继承Thread类
		1.创建子类对象继承Thread
		2.重写run方法
		3.使用时创建子类对象
		4.调用start方法，开启线程
	2.实现Runnable接口	好处：避免了单继承的局限性、将线程任务和开启线程分离，解耦
		1.创建实现类实现Runnable接口
		2.重写run方法
		3.使用时创建实现类对象
		4.创建Thread对象，构造方法中传入实现类对象
		5.调用start犯法，开启新线程
	3.匿名内部类（继承Thread类、实现Runnable接口）



14.开启一个新线程，就创建了一个新的栈内存



15.匿名内部类的作用：
	简化代码：把子类继承父类（实现类实现接口），重写父类（接口）方法，创建子类（实现类）对象的操作放到一步完成
	最终产物：子类/实现类对象



16.使用线程同步解决线程安全问题：
	1.同步代码块
	2.同步方法				（方法上加上sync修饰符）
	3.Lock锁机制   jdk1.5之后lock接口    	（lock获取锁、unlock释放锁）
		1.成员位置创建lock接口实现类对象
		2.在可能出现线程安全问题前调用lock获取锁
		3.在可能出现线程安全问题后调用unlock释放锁（最好放入finally中）


17.线程的6种状态：
	新建（NEW）、运行（RUNNABLE）、阻塞(BLOCKED)、死亡(TERMINATED)、限时等待(TIMED_WAITING)、无限等待(WAITING)


18.sleep(long ms) 和 wait(long ms) 的区别
	sleep需要等待时间到自动醒来
	wait可以被notify或者notifyAll方法唤醒，否则等待时间到自动醒来


19.网络编程三要素：
	ip
	端口	2个字节  0-65535
	协议	UDP：面向无连接
		TCP：面向连接


20lambda表达式：函数式编程
	
	格式：		()  ->  {方法体}
	使用条件: 	有接口，且接口中有且只有一个抽象方法，当此接口被当做参数传递时，可以使用lambda表达式，重写接口中的抽象方法



21.lambda和匿名抽象类区别：
	1.所需类型不同：lambda只能用于接口，匿名内部类可以是接口、抽象类、具体类
	2.使用限制不同：lambda只能用于接口中有且只有一个抽象方法时，多余1个时只能使用匿名内部类
	3.编译方式不同：匿名内部类在编译后会生成单独的字节码文件、lambda编译后不生成单独的字节码文件，对应的字节码在运行时动态生成


22.方法引用：
	引用运算符   ::
	
	lambda被引用方法替代时，除了对象的实例方法是第一个参数作为调用方法的对象，其他参数传递进去
	其他的所有情况都是把参数全部传递

23.函数式接口
	有且只有一个抽象方法的接口    用注解@FunctionalInterface表示
	可以作为方法的参数或者返回值



24.Stream流：真正把函数式编程引入java
	生成流---》中间操作---》终结操作



25.类加载机制：
	类加载（类初始化）步骤：
		1.类的加载 
			将class文件读入内存，并为之创建一个java.lang.Class对象
			任何类被加载时，系统都会为其创建一个java.lang.Class对象
		2.类的链接
			验证阶段：用于验证被加载的类是否有正确的内部结构
			准备阶段：用于对类变量分配内存，并设置默认初始化值
			解析阶段：将类的二进制数据中的符号引用替换为直接引用
		3.类的初始化
			对类变量进行初始化

	类的初始化步骤：
		假如给类还未被加载和连接，则程序先加载并连接该类
		假如该类的直接父类还未被初始化，则先初始化其直接父类
			（系统初始化一个类时，总会保证其类的所有父类都已经被初始化）
			（所以系统永远最先加载的是java.lang.Object类）
		假如类中有初始化语句，则系统依次执行这些初始化语句


	类记载时机：一个类或接口首次被使用时加载，一个类或接口不会被加载两次
		1.创建类的实例对象
		2.调用类的类方法
		3.访问类或接口的类变量或为其赋值
		4.使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
		5.初始化该类的子类
		6.直接使用java.exe命令运行某个主类
	
	类加载器：负责把.class文件加载到内存，并为其创建java.lang.Class对象

	jvm的内置类加载器：
		BootStrap Class Loader (默认为null)  >  PlatForm Class Loader  >  System Class Loader 

	JVM的类加载机制：
		全盘负责、父类委托、缓存机制
	

26.反射
	获取Class对象的方法:
		1.Class.forName(com.aabb.A)		--源代码阶段
		2.A.class				--class阶段
		3.A.getClass()				--运行时阶段


27.模块化：JDK9正式推出
	类似于idea中的模块，A模块调用B模块的类时，需要B模块在module-info.txt中exports包，A模块在module-info.txt中requiredB模块


28.注解：JDk1.5之后，用于说明程序
	作用：	1.生成javadoc文档
		2.编译检查 @Override
		3.代码分析，使用反射技术抽取注解
	
	
	JDK内置注解：
		@Override			重写方法
		@Deprecated   			方法已过时
		@SuppressWarnings("all")  	压制所有警告，一般传递参数all

	自定义注解：
		格式：	元注解
			public @interface 注解名{ }
		本质：
			一个接口，继承自 java.lang.annotation.Annotation接口

		属性：
			注解中的抽象方法
	
		要求：
			1.属性的返回值类型：基本数据类型、String、枚举、注解、或以上数据类型的数组
			2.使用注解时，需要在括号里给属性赋值！如果不给赋值，需要在定义属性时加上default关键字给默认值
			3.如果只有一个属性需要赋值，并且属性的名称为value，此value可以省略不写
		
	元注解：
		用于描述注解的注解
		@Target  描述注解作用的位置
		@Retention 描述注解被保留的阶段
		@Documented 描述注解是否被抽取到API文档中
		@Inherited 描述注解是否被子类继承
		